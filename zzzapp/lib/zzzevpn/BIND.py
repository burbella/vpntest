#-----manages BIND configs-----

import glob
import json
import os
import re
import requests
import urllib.parse

#-----package with all the Zzz modules-----
import zzzevpn

class BIND:
    'BIND config processing'
    
    ConfigData: dict = None
    db: zzzevpn.DB = None
    util: zzzevpn.Util = None
    settings: zzzevpn.Settings = None
    list_manager: zzzevpn.ListManager = None
    memory: zzzevpn.Memory = None
    update_file: zzzevpn.UpdateFile = None
    webpage: zzzevpn.Webpage = None

    data_validation: zzzevpn.DataValidation = None
    service_name = 'bind'
    dns_requests_data = ''

    def __init__(self, ConfigData: dict=None, db: zzzevpn.DB=None, util: zzzevpn.Util=None, settings: zzzevpn.Settings=None):
        if ConfigData is None:
            config = zzzevpn.Config(skip_autoload=True)
            self.ConfigData = config.get_config_data()
        else:
            self.ConfigData = ConfigData
        if db is None:
            self.db = zzzevpn.DB(self.ConfigData)
            self.db.db_connect(self.ConfigData['DBFilePath']['Services'])
        else:
            self.db = db
        if util is None:
            self.util = zzzevpn.Util(self.ConfigData, self.db)
        else:
            self.util = util
        if settings is None:
            self.settings = zzzevpn.Settings(self.ConfigData, self.db, self.util)
        else:
            self.settings = settings
        if not self.settings.SettingsData:
            self.settings.get_settings()
        self.list_manager = zzzevpn.ListManager(self.ConfigData, self.db, self.util)
        self.memory = zzzevpn.Memory(self.ConfigData, self.db, self.util)
        self.update_file = zzzevpn.UpdateFile(self.ConfigData, self.db, self.util)

    #--------------------------------------------------------------------------------
    
    def make_zone_entry(self, domain):
        return f'zone "{domain}" {{ type master; notify no; file "null.zone.file"; }};\n'

    #--------------------------------------------------------------------------------

    def update_dns_deny_zones(self, domain_list: list, custom_dst_dir: str=''):
        zone_file_data = ['// Custom BIND DNS-Deny List auto-generated by Zzz\n\n']
        if domain_list:
            for domain in domain_list:
                zone_file_data.append(self.make_zone_entry(domain))
        dst_filepath = self.ConfigData['UpdateFile']['bind']['dst_filepath']
        if custom_dst_dir:
            if custom_dst_dir not in self.ConfigData['Directory']['BINDallowedCustomDirs']:
                print('error - bad directory')
                return
            dst_filepath = f'{custom_dst_dir}/dns-blacklist'
        with open(dst_filepath, 'w') as write_file:
            write_file.write(''.join(zone_file_data))

    #--------------------------------------------------------------------------------
    
    def update_country_zone_file(self):
        country_file_data = []
        should_block_country_tld = False
        if self.settings.is_setting_enabled('block_country_tld') or self.settings.is_setting_enabled('block_country_tld_always'):
            should_block_country_tld = True
        if should_block_country_tld and self.settings.BlockedCountries:
            blocked_country_codes = self.settings.BlockedCountries.keys()
            if blocked_country_codes:
                for country_code in blocked_country_codes:
                    country_file_data.append(self.make_zone_entry(country_code))
        filepath = '{}/countries.conf'.format(self.ConfigData['Directory']['Settings'])
        with open(filepath, 'w') as write_file:
            write_file.write(''.join(country_file_data))
    
    #--------------------------------------------------------------------------------
    
    # self.settings.is_setting_enabled('block_tld_always')
    # apply DNS TLD blocks in "open" VPN's?
    def update_tld_zone_file(self):
        tld_file_data = []
        if self.settings.BlockedTLDs:
            for tld in self.settings.BlockedTLDs.keys():
                tld_file_data.append(self.make_zone_entry(tld))
        filepath = '{}/tlds.conf'.format(self.ConfigData['Directory']['Settings'])
        with open(filepath, 'w') as write_file:
            write_file.write(''.join(tld_file_data))
    
    #--------------------------------------------------------------------------------
    
    #TODO: remove this since ListManager handles this now
    def gen_bind_settings_config(self, src_filepath, dst_filepath):
        with open(src_filepath, 'r') as read_file, open(dst_filepath, 'w') as write_file:
            file_data = ''
            for item in read_file:
                file_data += 'zone "' + item.rstrip() + '" { type master; notify no; file "null.zone.file"; };\n'
            write_file.write(file_data)

    #TODO: remove this since ListManager handles this now
    #-----re-generates BIND settings config files-----
    def update_bind_settings_files(self):
        bind_settings_dir = self.ConfigData['Directory']['Settings']
        for filename in ['autoplay', 'social', 'telemetry']:
            #-----generate config-----
            src_filepath = f'{bind_settings_dir}/{filename}.txt'
            dst_filepath = f'{bind_settings_dir}/{filename}.conf'
            self.gen_bind_settings_config(src_filepath, dst_filepath)
    
    #--------------------------------------------------------------------------------
    
    #TODO: ListManager will merge all the DNS lists into one big file
    #      separate Settings files will no longer be used
    #-----make the latest DNS config-----
    # actions: add_domains, replace_domains, add_ips, replace_ips
    def generate_dns_file(self, request_id, action):
        print('BIND.generate_dns_file(): START', flush=True)
        
        # assembled_list = self.assemble_list(request_id, service_name, action)
        assembled_list = self.list_manager.assemble_list(request_id, self.service_name, action)
        
        #TODO: finish this
        #-----use the settings list to filter out hosts from the main list-----
        settings_list = self.util.get_settings_domains()
        #assembled_list.extend(settings_list)
        
        if self.ConfigData['Debug']:
            print('Assembled List:')
            print(assembled_list, flush=True)
        
        #TODO: test if separate domain/subdomain files work OK
        #      still need to prevent duplicates
        #
        # BIND will refuse to run if 2 duplicate zones are created,
        #     so prevent that from happening with some careful list checking
        # Check the assembled list (new and old entries) for overlapping domains and subdomains
        # Remove any subdomains that are already covered by a matching domain
        #     EXCEPTION: Settings domains override everything
        #
        # BIND zone config file generated by this script: /etc/named/dns-blacklist
        #     (customize in config file)
        #
        # EXAMPLES:
        #     example.com (allow this)
        #     test.example.com (reject because its domain is on the list)
        #     test.domain.zzz (allow this if domain.zzz is not on the list)
        #     zzz-sample-settings.zzz (reject this if www.zzz-sample-settings.zzz is on the Settings list)
        #     test.zzz-sample-settings.zzz (reject this if www.zzz-sample-settings.zzz is on the Settings list)
        #
        domain_list = self.util.remove_subdomains_with_matching_domains(assembled_list, settings_list)
        
        #-----update country TLD blocks-----
        self.update_country_zone_file()
        
        #-----update other TLD blocks-----
        self.update_tld_zone_file()
        
        if self.ConfigData['Debug']:
            print('Cleaned List:')
            print(domain_list, flush=True)
        
        #-----set this to the filename being copied, after generating the file and saving it with a date in the filename-----
        src_filepath = self.ConfigData['UpdateFile']['bind']['src_filepath']
        backup_file = self.update_file.save_file(src_filepath, domain_list)
        
        #-----convert domains to zones and save to the bind DNS blacklist file-----
        self.update_dns_deny_zones(domain_list)
        
        # save the src filepath in the DB
        sql = 'update update_file set src_filepath=? where service_request_id=?'
        params = (backup_file, request_id)
        self.db.query_exec(sql, params)
        
        #-----request a bind reload-----
        # do not make a request if there is a pending reload request already
        pending_reloads = self.db.count_pending_requests(self.service_name, 'reload')
        if (pending_reloads==0):
            self.db.request_reload(self.service_name)
            self.util.work_available(1)
        
        print('BIND.generate_dns_file(): END', flush=True)

    #--------------------------------------------------------------------------------

    # this replaces generate_dns_file()
    def generate_listmanager_dns_file(self, request_id, action):
        print('BIND.generate_listmanager_dns_file(): START', flush=True)

        # just the user's deny-list
        # this will auto-update zzz_list entries
        user_deny_list = self.list_manager.assemble_list(request_id, self.service_name, action)
        # includes all deny-lists merged together and de-duped
        complete_domain_list = self.list_manager.generate_combined_list('dns-deny')

        #-----update country TLD blocks-----
        self.update_country_zone_file()
        
        #-----update other TLD blocks-----
        self.update_tld_zone_file()

        #-----set this to the filename being copied, after generating the file and saving it with a date in the filename-----
        # this can be used to recover old versions of the user's deny-list
        src_filepath = self.ConfigData['UpdateFile']['bind']['src_filepath']
        backup_file = self.update_file.save_file(src_filepath, user_deny_list)

        #-----convert domains to zones and save to the bind DNS blacklist file-----
        self.update_dns_deny_zones(complete_domain_list)

        # save the src filepath in the DB
        sql = 'update update_file set src_filepath=? where service_request_id=?'
        params = (backup_file, request_id)
        self.db.query_exec(sql, params)

        #-----request a bind reload-----
        # do not make a request if there is a pending reload request already
        pending_reloads = self.db.count_pending_requests(self.service_name, 'reload')
        if (pending_reloads==0):
            self.db.request_reload(self.service_name)
            self.util.work_available(1)

        print('BIND.generate_listmanager_dns_file(): END', flush=True)
        return

    #--------------------------------------------------------------------------------
    
    # install lists to BIND config files in /etc/bind
    def update_bind_config_with_listmanager(self):
        complete_domain_list = self.list_manager.get_list_entries(list_name=self.ConfigData['CombinedLists']['dns-deny'])
        self.update_dns_deny_zones(complete_domain_list)
        self.db.request_reload('bind')
        self.util.work_available(1)

    #--------------------------------------------------------------------------------
    
    def make_webpage(self, environ, pagetitle):
        if self.webpage is None:
            self.webpage = zzzevpn.Webpage(self.ConfigData, self.db, 'Edit DNS', self.settings)
        
        output = self.webpage.make_webpage(environ, self.make_EditDNSPage(environ))
        
        return output
    
    #--------------------------------------------------------------------------------
    
    #-----process POST data-----
    def handle_post(self, environ, request_body_size):
        if self.webpage is None:
            self.webpage = zzzevpn.Webpage(self.ConfigData, self.db, '', self.settings)
        
        #-----read the POST data-----
        request_body = environ['wsgi.input'].read(request_body_size)
        
        #-----decode() so we get text strings instead of binary data, then parse it-----
        raw_data = urllib.parse.parse_qs(request_body.decode('utf-8'))
        action = raw_data.get('action', None)
        if action!=None:
            action = action[0]
        filename = raw_data.get('filename', None)
        if filename!=None:
            filename = filename[0]
        uploaded_domain_list = raw_data.get('domain_list', None)
        if uploaded_domain_list!=None:
            uploaded_domain_list = uploaded_domain_list[0]
        download_site = raw_data.get('download_site', None)
        if download_site!=None:
            download_site = download_site[0]
        #handle_invalid_domains
        handle_invalid_domains = raw_data.get('handle_invalid_domains', None)
        if handle_invalid_domains is None:
            handle_invalid_domains = 'drop'
        else:
            handle_invalid_domains = handle_invalid_domains[0]
        
        #-----return if missing data-----
        if (request_body_size==0 or action==None):
            self.webpage.error_log(environ, 'ERROR: missing data')
            return 'ERROR: missing data'
        
        #-----validate data-----
        if self.data_validation==None:
            self.data_validation = zzzevpn.DataValidation(self.ConfigData)
        data = {
            'action': action,
            'filename': filename,
            'domain_list': uploaded_domain_list,
            'handle_invalid_domains': handle_invalid_domains,
        }
        if not self.data_validation.validate(environ, data):
            return self.webpage.error_log(environ, 'ERROR: data validation failed')
        
        if action=='add_domains':
            return self.process_domains(environ, uploaded_domain_list, action, handle_invalid_domains)
        elif action=='replace_domains':
            return self.process_domains(environ, uploaded_domain_list, action, handle_invalid_domains)
        elif action=='get_dns_file':
            return self.get_dns_replacement_file(filename)

        return self.webpage.error_log(environ, 'ERROR: invalid action')
    
    #--------------------------------------------------------------------------------
    
    def make_EditDNSPage(self, environ):
        self.get_dns_requests(100)
        EditDnsHTML = {
            'CSP_NONCE': environ['CSP_NONCE'],
            'dns_backup_files': self.list_dns_backup_files(environ),
            'dns_domains_to_replace': self.get_dns_replacement_file(),
            'html_dns_requests': self.show_dns_requests(),
        }
        body = self.webpage.load_template('EditDNS')
        return body.format(**EditDnsHTML)
    
    #--------------------------------------------------------------------------------
    
    def get_dns_requests(self, limit: int=50):
        if not self.util.is_int(limit):
            limit = 50
        sql = f'''SELECT sr.id as sr_id, sr.req_date, sr.action, sr.status,
                    sr.details, uf.id as uf_id, uf.file_data, uf.src_filepath
                FROM service_request sr left outer join update_file uf on sr.id=uf.service_request_id
                WHERE sr.service_name=? and (sr.action in (?, ?))
                ORDER BY sr.id desc
                LIMIT {limit}'''
        params = (self.service_name, 'add_domains', 'replace_domains')
        (colnames, rows, rows_with_colnames) = self.db.select_all(sql.format(str(limit)), params)
        self.dns_requests_data = rows_with_colnames
    
    #--------------------------------------------------------------------------------
    
    def show_dns_requests(self):
        html = '''
        <table><tr>
        <th>sr_id</th><th>req_date</th><th>action</th><th>status</th>
        <th class="width_300">Details</th><th>uf_id</th><th class="width_200">File Data</th><th>src_filepath</th>
        </tr>
        {}
        </table>
        '''
        
        options = {
            'collapsable_html': {
                'details': 'details_',
                'file_data': 'file_data_',
            },
        }
        custom_html_table = self.util.custom_html_table(self.dns_requests_data, options)
        
        return html.format(custom_html_table)
    
    #--------------------------------------------------------------------------------

    def get_dns_replacement_file(self, oldfile=''):
        filepath = self.ConfigData['ApacheTempFiles'] + '/' + oldfile
        if oldfile=='':
            filepath = self.ConfigData['UpdateFile']['bind']['src_filepath']
        return self.util.get_filedata(filepath)

    #--------------------------------------------------------------------------------
    
    def list_dns_backup_files(self, environ):
        html = '''
        <table><tr><th>Date</th><th>File</th></tr>
        {}
        </table>
        '''
        
        base_filepath = self.ConfigData['UpdateFile']['bind']['src_filepath']
        dns_files = glob.glob(os.path.join(self.ConfigData['ApacheTempFiles'], 'dns-blacklist.txt.*'))
        
        file_regex = r'^' + base_filepath + r'\.(\d\d\d\d)\-(\d\d)\-(\d\d)\-(\d\d)\-(\d\d)\-(\d\d)$'
        regex_pattern = re.compile(file_regex, re.IGNORECASE)
        
        ctr = 0
        html_table_rows = ''
        for item in sorted(dns_files, reverse=True):
            match = regex_pattern.match(item)
            filename = os.path.basename(item)
            if match:
                file_date = '{}-{}-{} {}:{}:{}'.format(match.group(1), match.group(2), match.group(3), match.group(4), match.group(5), match.group(6))
                html_table_rows += f'<tr><td>{file_date}</td><td><a class="clickable get_dns_backup_file" data-onclick="{filename}">{filename}</a></td></tr>'
                ctr += 1
                # stop after 500 files
                if ctr>=500:
                    break
        
        return html.format(html_table_rows)
    
    #--------------------------------------------------------------------------------
    
    def process_domains(self, environ, uploaded_domain_list, action, handle_invalid_domains):
        result = { 'status': '', 'error_msg': '', }
        if not uploaded_domain_list:
            result = { 'status': 'error', 'error_msg': 'ERROR: no domains uploaded', }
            return json.dumps(result)
        domain_list = uploaded_domain_list.rstrip('\n').splitlines()

        list_rejected_domains = False
        if handle_invalid_domains=='report':
            list_rejected_domains = True
        
        validation_result = self.util.validate_domain_list(domain_list, list_rejected_domains)
        if validation_result['rejected_domains']:
            #TODO: return an ERROR mentioning the bad domain
            result['status'] = 'success'
            result['error_msg'] = 'invalid domain(s) found and discarded'
            if handle_invalid_domains=='report':
                result['status'] = 'error'
                result['error_msg'] = 'invalid domain(s) found, not saving any domains'
                return json.dumps(result)
        
        domain_list = validation_result['accepted_domains']
        if not domain_list:
            result['status'] = 'error'
            result['error_msg'] = 'ERROR: no accepted domains'
            return json.dumps(result)
        
        # DB: service_request table (service_name=bind, action=add_domains)
        self.db.insert_service_request(self.service_name, action)
        
        service_request_id = self.db.cur.lastrowid
        
        # DB: update_file table
        # apache just fills-in the file_data
        # the daemon will fill-in the src filepath and dst filepath
        # 
        sql_update_file = "insert into update_file (service_request_id, file_data) values (?, ?)"
        params_update_file = (service_request_id, '\n'.join(domain_list))
        self.db.query_exec(sql_update_file, params_update_file)
        
        self.util.work_available(1)
        
        result['status'] = 'success'
        return json.dumps(result)
    
    #--------------------------------------------------------------------------------
